#
# ~/.bashrc
#

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

# Source bash completion
[[ -r /usr/share/bash-completion/bash_completion ]] && . /usr/share/bash-completion/bash_completion

# Get current branch in git repo
get_git_branch() {
    BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"
    if [ ! "${BRANCH}" == "" ]
    then
        if [ "${BRANCH}" == "HEAD" ]; then
            BRANCH="${BRANCH}@$(git rev-parse --short HEAD 2>/dev/null)"
        fi
        STATUS=$(get_git_status)
        printf "[%s%s]" "${BRANCH}" "${STATUS}"
    fi
}

# Get current status of git repo
get_git_status() {
    FLAG_RENAMED=1
    FLAG_MODIFIED=$((1<<1))
    FLAG_ADDED=$((1<<2))
    FLAG_DELETED=$((1<<3))
    FLAG_COPIED=$((1<<4))
    FLAG_UNTRACKED=$((1<<5))
    flags=0
    while read -r line; do
        [[ "${line:0:2}" =~ ^.?R.?$ ]] && (( flags |= FLAG_RENAMED ))
        [[ "${line:0:2}" =~ ^.?A.?$ ]] && (( flags |= FLAG_ADDED ))
        [[ "${line:0:2}" =~ ^.?D.?$ ]] && (( flags |= FLAG_DELETED ))
        [[ "${line:0:2}" =~ ^.?C.?$ ]] && (( flags |= FLAG_COPIED ))
        [[ "${line:0:2}" =~ ^.?M.?$ ]] && (( flags |= FLAG_MODIFIED ))
        [[ "${line:0:2}" =~ ^\?\?$ ]] && (( flags |= FLAG_UNTRACKED ))
    done <<< "$(git status --porcelain 2>/dev/null)"
    (( flags & FLAG_RENAMED )) && printf ">"
    (( flags & FLAG_MODIFIED )) && printf "*"
    (( flags & FLAG_ADDED )) && printf "+"
    (( flags & FLAG_DELETED )) && printf "-"
    (( flags & FLAG_COPIED )) && printf "~"
    (( flags & FLAG_UNTRACKED )) && printf "?"
}

get_ps1() {
    # Set the shell prompt
    #printf '[\u@\h \W]\$ '

    local reset="\\[$(tput sgr0)\\]"
    local black="\\[$(tput setaf 0)\\]"
    local red="\\[$(tput setaf 1)\\]"
    local green="\\[$(tput setaf 2)\\]"
    local yellow="\\[$(tput setaf 3)\\]"
    local blue="\\[$(tput setaf 4)\\]"
    local magenta="\\[$(tput setaf 5)\\]"
    local cyan="\\[$(tput setaf 6)\\]"
    local white="\\[$(tput setaf 7)\\]"

    if command -v "git" >/dev/null 2>&1
    then
        local gitbranch="${magenta}\$(get_git_branch)${reset}"
    fi

    if [ "$USER" = "root" ]
    then
        local usercolor="${red}"
    else
        local usercolor="${green}"
    fi

    if [ -n "$SSH_CLIENT" ]
    then
        local hostinfo="${usercolor}\\u${reset}@${blue}\\h${reset}:"
    else
        local hostinfo=""
    fi

	printf '%s' "[${red}\\A${reset}] ${hostinfo}${yellow}\\w${reset}${gitbranch}${cyan}\$${reset} "
}
PS1="$(get_ps1)"

# Use a big shared history
export HISTSIZE=100000
export HISTFILESIZE=200000
export HISTCONTROL=ignorespace:ignoredups
export HISTFILE=~/.bash_history_full
export PROMPT_COMMAND="builtin history -a ; builtin history -c ; builtin history -r"

# Nicer directory listings
if command -v "exa" >/dev/null 2>&1; then
    alias ls="exa --git"
    alias tree="exa -T --git"
else
    alias ls="ls --color=auto"
fi

# Nicer file viewing/paging with linenumbers and highlighting
if command -v "bat" >/dev/null 2>&1; then
    alias cat="bat"
    alias less="bat"
fi

# Highlight grep matches
alias grep="grep --color=auto"

# Use NVIM if available
if command -v "nvim" >/dev/null 2>&1; then
    alias vim="nvim"
fi

# Use NeoMutt if available
if command -v "neomutt" >/dev/null 2>&1; then
    alias mutt="neomutt"
fi

if command -v "git" >/dev/null 2>&1; then
    alias gwdiff="git diff --no-index --color-words"
fi

if command -v "transmission-remote" >/dev/null 2>&1; then
    transmission-remote() {
        command transmission-remote "$TRANSMISSION_HOST" "$@"
    }
fi

# Colored man pages
if [[ "$OSTYPE" = solaris* ]]
then
    if [[ ! -x "$HOME/bin/nroff" ]]
    then
        mkdir -p "$HOME/bin"
        cat > "$HOME/bin/nroff" <<EOF
#!/bin/sh
if [ -n "\$_NROFF_U" -a "\$1,\$2,\$3" = "-u0,-Tlp,-man" ]; then
    shift
    exec /usr/bin/nroff -u\$_NROFF_U "\$@"
fi
#-- Some other invocation of nroff
exec /usr/bin/nroff "\$@"
EOF
        chmod +x "$HOME/bin/nroff"
    fi
fi

man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;34m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[1;44;36m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        PAGER="${commands[less]:-$PAGER}" \
        _NROFF_U=1 \
        PATH="$HOME/bin:$PATH" \
            man "$@"
}

# Nicer substring search with fzf
if command -v "fzf" >/dev/null 2>&1; then
    [ -f "$HOME/.fzf.bash" ] && source "$HOME/.fzf.bash"

    function fzfedit {
        local file
        file=$(fzf)
        [ "$?" -eq 0 -a ! -z "$file" ] && "$EDITOR" "$file"
    }
    bind -x '"\C-p": fzfedit;'
fi

[ -f ~/.fzf.bash ] && source ~/.fzf.bash
